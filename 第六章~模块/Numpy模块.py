import numpy as np
# 数组创建：2层刮号为一维数据，3层为二维数据，4层为多维数据,外弧刮号+内方刮号.
# 从列表创建：np.array([1, 2, 3]) 或 np.array([[1, 2], [3, 4]])
# 创建特殊数组：np.zeros((3, 3))（全部是0的数组，3行3列）、np.ones((2, 4))（全是1的数组,2行4例）、np.eye(3)（生成m*n矩阵数组）
# 创建序列数组：np.arange(0, 10, 2):可设定起始(默认0),结束（必传,左闭右开区间）,步长值,可以是任意数据类型(浮点数,整数,负数,字符串布尔值等)
#             np.linspace(0, 1, 5):生成等间距的数字,可设定起始,结束,生成的样本数量(默认为50),可以是任意数据类型(浮点数,整数,负数,字符串布尔值等).
# 创建随机数组：np.random.standard_normal 和 random.randn在功能上是等价的，都用于生成标准正态分布（均值为0，标准差为1）的随机数,使用上,输出数组时前者需要多添加一个括号,以元组方式传递
# np.random.randn(): 生成的随机数服从标准正态分布,均值为0，标准差为1，大部分值集中在-1到1之间，极端值（如±3以上）概率较低,
#                 ():生成一个单一浮点数。(5):生成一个包含5个元素的一维数组,(3, 4):生成一个3行4列的二维数组,(2, 3, 4):生成一个2x3x4的三维数组。
# np.random.rand(2, 3):（0-1,不会生成负数)之间的随机且均匀的浮点数,包含0但不包含1,刮号里的参数设置与上行的random.randn()一样.
# np.random.randint(0, 10, (3, 3)):生成一个在 [low, high) 范围内的随机整数或数组，形状由 size 指定，并且数据类型由 dtype 指定。
# np.random standard_normal(10,8):产生10以下随机的8个浮点数,均值为0，标准差为1,():生成一个单一的浮点数。(size):生成一个指定形状的数组。(size, dtype):生成一个指定形状和数据类型的数组.
# np.random.choice(a, size=None, replace=True, p=None):如刮号是(10,8)有选择的产生0-9(含10)随机的8个整数.a: 一个一维数组或整数,size: 输出数组的形状，可以是整数或元组。
#                                                replace: 是否允许重复抽样。默认为True，表示允许重复抽样。p: 每个元素被抽取的概率数组。必须是非负实数，并且其总和应等于1
#                                              在 replace=False 的情况下，size 必须小于或等于数组 a 的长度，否则会引发错误。
# np.random.seed(): 不提供参数时，使用当前系统时间或其他来源生成一个随机种子,()刮号设置参数后,生成的随机数小于该参数,保证每次生成的随机数相同,位置要放在生成随机数np.random standard_normal等的前一行,无需赋值变量名.
#
# np.array()函数：生成的数组类型为ndarray，是一个同构的多维数组，用于存放相同类型元素的集合，与列表不同，ndarray要求所有元素必须是同一数据类型
# arr = np.array([[1, 2, 3], [4, 5, 6]],dtype=int)      # np.array函数创建的数组数据类型(dtype=float32)可以通过astype或np.asarray修改数据类型
# print(arr.shape)  # (2, 3) 数组形状，shape是查看数组属性，对于一维数组返回(元素个数,)，二维数组返回(行数, 列数)，多维数组则包含各维度的大小
# 可以通过reshape和resize重新分行分列
# h.T和transpose将行和列反转
# hstack和vstack:在原来的数组中横向和纵向堆积出数组
# tolist:将数组转换成列表
# flatten(order='C'):将多维数组转换成一维数组,'C'将原来数组中的按行排序在一维数组中,'F'按列排列
# print(arr)
# print(arr.ndim)   # 2 维度
# print(arr.size)   # 6 元素总数
# print(arr.dtype)  # int64 查看数据类型
# print(arr[:,2])  # 取每一行的第3个元素，1(行):,3(列)，冒号+逗号分开，前面没有数字是只取列的元素

# np.array数组的运算与list最大的优势就是可以在每个元素进行向量化运算,不需要用for遍历出来每个元素进行运算
# 数组运算:加减乘除，求平均数、四舍五入(可以精确到指定位数)，按axis轴计算等各种运算
# 基本数学运算：arr + arr1 + arr2（对应元素运算）
# 矩阵运算：np.dot(arr1, arr2)（点乘）、arr1 @ arr2（矩阵乘法）
# axis=0，轴按列表的行或例的各种运算(0为列，1为行)
# 统计运算：np.sum(arr)求和、np.mean(arr)均值、np.prod相乘、np.round(decimals=2，表示精确到小数2位)四舍五入、np.max(arr)、np.min(arr,axis=0)   # axis=0，轴按列表的行或例的各种运算(0为行，1为例)
# np.cumsum()累计求和(计算股价连续收益率常用),cumprod()累积求乘积(离散累积收益常用)
# 广播机制：不同形状数组间的运算，NumPy会自动扩展至相同尺寸或相同倍数
# math的数据不能用于numpy进行运算，python源数据或函数都是可以在numpy中运输的
# np.polyfit(x ,y,1):计算一次回归系数,2为二次回归,使用np.polyval返回计算结果
#
# 数组索引与切片
# arr2 = np.array([[1, 2, 3, 4, 5],[1, 2, 3, 4, 5]])
# print(arr2[1:4])  # [2, 3, 4]   索引出1-4的数(不含4)
# print(arr2[arr < 3])  # [1, 2] 条件筛选出小于3的数
# 在多条件选择时numpy可以直接采用比较运算选股,比python中的filter好用

# 通过bool值或设定参数当索引，找出需要的元素
arr3=np.array([0,10,20,30,40,50,60,70,80,90])
rs=arr3[(arr3<80) & (arr3>10)] # 可以直接采用比较运算选股,不能用and和or，只能用&和|符号，否则程序会报错！
print(rs,'结果大于或等于80,小于或等于10的数字都会去除')
ma=np.array([0,0,1,1,0,1,0,0,1,1],dtype=bool)
print(arr3[ma],'通过bool值当索引找出需要的元素')
ms=np.where(arr3>30)
print(ms, '通过np.where设定>30值当索引找出需要的元素，通过where获取需要元素的下标位置')
print(arr3[ms],'np.where设定>30对应的元素值')
#
# np.where语法:主要用于根据条件筛选数组元素或进行条件替换操作。
# 1. 条件筛选：当仅提供条件参数时，返回满足条件的元素索引。例如 np.where(arr > 5) 会返回数组中所有大于5的元素位置下标.
# 2. 元素替换：根据条件将数组中的值替换为指定值。例如 np.where(arr > 5, "大", "小") 会将大于5的元素替换为"大"，其余替换为"小".
# 3. 多条件组合：支持通过 &（与）、|（或）连接多个条件，实现复杂筛选或替换逻辑.
# 4. 数据清洗：常用于异常值检测、条件过滤等场景，例如结合Pandas对DataFrame进行条件操作
# 5.可以通过设置条件满足0,1,-1给出开仓信号,策略中常用, 用于根据条件筛选和替换数组中的元素，或者获取满足条件的元素的索引.
# 创建一个示例数组
arr4 = np.array([10, 20, 30, 40, 50])
# 使用 np.where 根据条件替换了数组中的元素
new_arr = np.where(arr4,arr4 > 25, arr4 * 2)
print(new_arr,' 使用 np.where 根据条件替换了数组中的元素')

# np.sign语法,只接受-1,0,1三个参数,非常适合开仓\持仓\平仓三个信号.返回与输入数组形状相同的数组，其中每个元素的符号被提取出来：
# 正数变为 1，负数变为 -1，零保持不变。在数值计算中用于判断元素的正负性。

arr5 = np.array([-5, -2, 0, 3, 7])
# 使用 np.sign 提取 arr 数组中每个元素的符号
signs = np.sign(arr5)
# 示例:
# 计算收盘价的5日和20日滚动均值
# data['MA_5'] = data['Close'].rolling(window=5).mean()
# data['MA_20'] = data['Close'].rolling(window=20).mean()
# 计算短期均线减去长期均线的差值
# data['Diff'] = data['MA_5'] - data['MA_20']
# 使用np.sign生成买卖信号，正值表示短期均线高于长期均线，负值表示短期均线低于长期均线，零值表示两者相等。
# .diff() 计算相邻行之间的差异，即符号的变化。.fillna(0) 填充NaN值为0，因为初始值没有前一行可供比较。
# 1 表示买入信号，-1 表示卖出信号，0 表示无信号

# data['Signal'] = np.sign(data['Diff']).diff().fillna(0)
# 将信号转换为实际的买卖操作
# data['Position'] = data['Signal'].replace({1: 'Buy', -1: 'Sell', 0: 'Hold'})

# np.where和mask对比:两个语法一致.用bool判断替换两个刚好相反.
# where：保留满足条件（True）的位置的原始值，不满足条件（False）的位置替换为指定值或 NaN ,numpy下,速度更快
# mask：在满足条件（True）的位置替换为指定值或 NaN，不满足条件（False）的位置保留原始值,pandas下，速度更慢
# 掩码Mask():数据筛选与过滤
# NumPy/Pandas：通过布尔数组（True/False）筛选满足条件的数据子集，例如提取数组中大于某值的元素或DataFrame中符合特定条件的行。
# 示例：arr[arr > 0] 可直接筛选数组中大于0的元素。
# 条件数据替换
# Pandas：mask() 函数可将满足条件的值替换为指定值（如NaN），常用于数据清洗、脱敏或异常值处理。
# 示例：df.mask(df['score'] < 80, other=np.nan) 可将分数低于80的值替换为NaN。


